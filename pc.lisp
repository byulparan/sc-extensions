(in-package :pc)

(defvar *diatonic-major*
   '((:i . (0 . :^))
     (:i6 . (0 . :^6))
     (:i64 . (0 . :^64))
     (:i7 . (0 . :^7))
     (:i- . (0 . :-))
     (:i-7 . (0 . :-7))
     (:n . (1 . :^)) ; neopolitan
     (:n6 . (1 . :^6)) ; neopolitan
     (:ii . (2 . :-))
     (:ii6 . (2 . :-6))
     (:ii7 . (2 . :-7))
     (:ii9 . (2 . :-9))
     (:ii^ . (2 . :^))
     (:ii^7 . (2 . :^7))
     (:iii . (4 . :-))
     (:iii6 . (4 . :-6))
     (:iii7 . (4 . :-7))
     (:iii^ . (4 . :^))
     (:iii^7 . (4 . :^7))
     (:iv . (5 . :^))
     (:iv6 . (5 . :^6))
     (:iv7 . (5 . :^7))
     (:iv- . (5 . :-))
     (:iv-7 . (5 . :-7))
     (:v . (7 . :^))
     (:v6 . (7 . :^6))
     (:v7 . (7 . :7))
     (:v- . (7 . :-))
     (:v-7 . (7 . :-7))
     (:b6 . (8 . :^))
     (:vi . (9 . :-))
     (:vi6 . (9 . :-6))
     (:vi7 . (9 . :-7))
     (:vi^ . (9 . :^))
     (:vi^7 . (9 . :^7))
     (:b7 . (10 . :^))
     (:viio . (11 . :o))
     (:viio7 . (11 . :o7))
     (:vii . (11 . :o))
     (:vii7 . (11 . :-7b5))))

(defvar *diatonic-minor*
  '((:i . (0 . :-))
    (:i6 . (0 . :-6))
    (:i64 . (0 . :-64))
    (:i7 . (0 . :-7))
    (:i^ . (0 . :^))
    (:i^6 . (0 . :^6))
    (:i^64 . (0 . :^64))
    (:i^7 . (0 . :^7))
    (:n . (1 . :^)) ; neopolitan
    (:n6 . (1 . :^6)) ; neopolitan
    (:ii . (2 . :o))
    (:ii6 . (2 . :o6))
    (:ii7 . (2 . :o7))
    (:ii- . (2 . :-))
    (:ii-6 . (2 . :-6))
    (:ii-7 . (2 . :-7))
    (:ii^ . (2 . :^))
    (:ii^7 . (2 . :^7))
    (:iii . (3 . :^))
    (:iii6 . (3 . :^6))
    (:iii7 . (3 . :^7))
    (:iii- . (3 . :-))
    (:iii-6 . (3 . :-6))
    (:iii-7 . (3 . :-7))
    (:iv . (5 . :-))
    (:iv6 . (5 . :-6))
    (:iv7 . (5 . :-7))
    (:iv^ . (5 . :^))
    (:iv^6 . (5 . :^6))
    (:iv^7 . (5 . :^7))
    (:v . (7 . :^))
    (:v^ . (7 . :^))
    (:v6 . (7 . :^6))
    (:v7 . (7 . :7))
    (:v- . (7 . :-))
    (:v-6 . (7 . :-6))
    (:v-6 . (7 . :-6))
    (:v-7 . (7 . :-))
    (:vi . (8 . :^))
    (:vi6 . (8 . :^6))
    (:vi7 . (8 . :^7))
    (:vi- . (8 . :-))
    (:vi-6 . (8 . :-6))
    (:vi-7 . (8 . :-7))
    (:vii . (10 . :^))
    (:vii6 . (10 . :^6))
    (:vii7 . (10 . :^7))
    (:viio . (11 . :o)) ;raised 7 (dim)
    (:viio6 . (11 . :o6)) ;raised 7 (dim)
    (:viio7 . (11 . :o7)) ; raised 7 (dim)
    ))

(defvar *scales*
  '((:pentatonic . (2 2 3 2))
    (:wholetone . (2 2 2 2 2))
    (:chromatic . (1 1 1 1 1 1 1 1 1 1 1))
    (:octatonic . (2 1 2 1 2 1 2))
    (:messiaen1 . (2 2 2 2 2))
    (:messiaen2 . (2 1 2 1 2 1 2))
    (:messiaen3 . (2 1 1 2 1 1 2 1))
    (:messiaen4 . (1 1 3 1 1 1 3))
    (:messiaen5 . (1 4 1 1 4))
    (:messiaen6 . (2 2 1 1 2 2 1))
    (:messiaen7 . (1 1 1 2 1 1 1 1 2))
    (:harmonic . (2 1 2 2 1 3))
    (:ionian . (2 2 1 2 2 2))
    (:dorian . (2 1 2 2 2 1))
    (:phrygian . (1 2 2 2 1 2))
    (:lydian . (2 2 2 1 2 2))
    (:lydian-dominant . (2 2 2 1 2 1))
    (:lydian-mixolydian . (2 1 2 1 2 1 2))
    (:mixolydian . (2 2 1 2 2 1))
    (:aeolian . (2 1 2 2 1 2))
    (:locrian . (1 2 2 1 2 2))))

(defvar *chord-syms*
   '((:^ . (0 4 7))
     (:^sus . (0 5 7))
     (:^6 . (4 7 0))
     (:^64 . (7 0 4))
     (:^7 . (0 4 7 11))
     (:^65 . (4 7 11 0))
     (:^43 . (7 11 0 4))
     (:^42 . (11 0 4 7))
     (:^2 . (11 0 4 7))
     (:^7#4 . (0 4 7 11 6))
     (:^9 . (0 4 7 11 2))
     (:7 . (0 4 7 10))
     (:9 . (0 4 7 10 2))
     (:65 . (4 7 10 0))
     (:43 . (7 10 0 4))
     (:2 . (10 0 4 7))
     (:42 . (10 0 4 7))
     (:- . (0 3 7))
     (:-sus . (0 5 7))
     (:-6 . (3 7 0))
     (:-64 . (7 0 3))
     (:-7 . (0 3 7 10))
     (:-65 . (3 7 10 0))
     (:-43 . (7 10 0 3))
     (:-42 . (10 0 3 7))
     (:-2 . (10 0 3 7))
     (:-9 . (0 3 7 10 2))
     (:o . (0 3 6))
     (:o6 . (3 6 0))
     (:o64 . (6 0 3))
     (:o7 . (0 3 6 8))
     (:o65 . (3 6 8 0))
     (:o43 . (6 8 0 3))
     (:o42 . (8 0 3 6))
     (:o2 . (8 0 3 6))
     (:-7b5 . (0 3 6 9))))

(defvar *chord-syms-scales*
  '((:^ . :ionian)
    (:^sus . :mixolydian)
    (:^6 . :ionian)
    (:^64 . :ionian)
    (:^7 . :ionian)
    (:^65 . :ionian)
    (:^43 . :ionian)
    (:^42 . :ionian)
    (:^2 . :ionian)
    (:^7#4 . :ionian)
    (:^9 . :ionian)
    (:7 . :mixolydian)
    (:9 . :mixolydian)
    (:65 . :mixolydian)
    (:43 . :mixolydian)
    (:2 . :mixolydian)
    (:42 . :mixolydian)
    (:- . :dorian)
    (:-sus . :mixolydian)
    (:-6 . :dorian)
    (:-64 . :dorian)
    (:-7 . :dorian)
    (:-65 . :dorian)
    (:-43 . :dorian)
    (:-42 . :dorian)
    (:-2 . :dorian)
    (:-9 . :dorian)
    (:o . :locrian)
    (:o6 . :locrian)
    (:o64 . :locrian)
    (:o7 . :locrian)
    (:o65 . :locrian)
    (:o43 . :locrian)
    (:o42 . :locrian)
    (:o2 . :locrian)
    (:-7b5 . :locrian)))

(defvar *chord->scale*
   '((:i . (0 . :ionian))
     (:i7 . (0 . :ionian))
     (:ii . (2 . :dorian))
     (:ii7 . (2 . :dorian))
     (:ii9 . (2 . :dorian))
     (:iii . (4 . :phrygian))
     (:iii7 . (4 . :phrygian))
     (:iv . (5 . :lydian))
     (:iv7 . (5 . :lydian))
     (:v . (7 . :mixolydian))
     (:v7 . (7 . :mixolydian))
     (:vi . (9 . :aeolian))
     (:vi7 . (9 . :aeolian))
     (:vii . (11 . :locrian))
     (:vii7 . (11 . :locrian))))


(defun pc (pitch)
  (mod pitch 12))

(defun pc? (pitch pc)
  (consp (member (mod pitch 12) pc)))

(defun quantize (pitch-in pc)
  (labels ((lp (inc pitch)
	     (cond ((pc? (+ pitch inc) pc) (+ pitch inc))
		   ((pc? (- pitch inc) pc) (- pitch inc))
		   ((< inc 7) (lp (+ inc 1) pitch))
		   (t (format t "no pc value to quantize to ~a ~a~%" pitch pc)))))
    (lp 0 (round pitch-in))))

(defun pc-random (lower upper pc)
  (if (null pc) -1
    (let ((choices (remove-if-not (lambda (x) (pc? x pc)) (loop for i from lower below upper
								collect i))))
      (if (null choices) -1
        (alexandria:random-elt choices)))))

(defun relative (pitch i pc)
  (setf i (round i))
  (if (= i 0) pitch
    (let ((inc (if (minusp i) #'- #'+)))
      (labels ((lp (p cnt)
		 (if (pc? p pc) (setf cnt (funcall inc cnt 1)))
		 (if (= cnt i) p
		   (lp (funcall inc p 1) cnt))))
	(lp (funcall inc pitch 1) 0)))))


(defun make-chord (lower upper number pc)
  (let ((chord '()))
    (labels ((lp (l u n p)
	       (if (< n 1) (mapcar #'identity (sort (remove -1 chord) #'<))
		 (let* ((range (- u l))
			(gap (round (/ range n)))
			(pitch (pc-random l (+ l gap) p)))
		   (if (< pitch 0) (setf chord (cons (pc-random lower upper p) chord))
		     (setf chord (cons pitch chord)))
		   (lp (+ l gap) u (- n 1) (if (> (length p) 1) (remove (mod (car chord) 12) p)
					     pc))))))
      (lp (round lower) (round upper) number pc))))

(defun degree (value pc)
  (labels ((lp (i lst)
	     (if (null lst) (progn
			      (format t "pitch not in pc~%")
			      -1)
	       (if (= (car lst) (mod value 12)) i
		 (lp (+ i 1) (cdr lst))))))
    (lp 1 pc)))

(defun quantize-list (lst pc)
  (mapcar #'(lambda (i) (quantize i pc)) lst))


;; ;; retrograde list
;; (define ivl:retrograde reverse)

(defun ivl-invert (lst &rest args)
  (let ((pivot (if (null args) (car lst)
                 (car args))))
    (cons (car lst) (mapcar (lambda (i) (- pivot (- i pivot))) (cdr lst)))))

(defun ivl-transpose (val lst)
  (mapcar (lambda (i) (+ i val)) lst))


(defun invert (lst pc &rest args)
  (if (null args) (quantize-list (ivl-invert lst) pc)
    (quantize-list (ivl-invert lst (car args)) pc)))

(defun transpose (val lst pc)
  (quantize-list (ivl-transpose val lst) pc))

(defun scale (root type)
  (if (assoc type *scales*) (labels ((lp (l current newlst)
				       (if (null l) (reverse (cons current newlst))
					 (lp (cdr l) (mod (+ current (car l)) 12) (cons current newlst)))))
			      (lp (cdr (assoc type *scales*)) (mod root 12) '()))
    (error "Scale type not found ~a" *scales*)))

(defun chord-to-scale (root type)
  (scale (mod (+ (cadr (assoc type *chord->scale*)) root) 12)
         (cddr (assoc type *chord->scale*))))

(defun chord (root type)
  (let ((chord (assoc type *chord-syms*)))
    (if chord (labels ((lp (l newlst)
			 (if (null l) (reverse newlst)
			   (lp (cdr l) (cons (mod (+ (car l) root) 12) newlst)))))
		(lp (cdr chord) '()))
      (error "Chord type not found ~s" type))))

(defun diatonic (root maj-min degree)
  (when (numberp degree)
    (setf degree (cdr (assoc degree '((0 . :i) (1 . :ii) (2 . :ii)
                                      (3 . :iii) (4 . :iii) (5 . :iv)
                                      (6 . :iv) (7 . :v) (8 . :vi) (9 . :vi)
                                      (10 . :vii) (11 . :vii))))))
  (let ((val (assoc degree
		    (if (eql :^ maj-min)
                        *diatonic-major*
                      *diatonic-minor*))))
    (chord (mod (+ root (cadr val)) 12) (cddr val))))


